# c++ 공부한거 정리하는 파일. 약 6개 챕터분량

## 코드형식을 기억하기위한 c++로 2차원 배열 만들기 코드

```c++
int main(){
    int **arr = new int*[5];// 더블포인터 생성해서 정수형포인터를 담을 
                            //정수형포인터배열 5칸짜리 만들기 (동적할당) 익숙해지자
    for(int i=0; i<5; i++){
      arr[i] = new int[5];
    }
    본문내용 들어갈 부분
    for(int i=0; i<5; i++){
      delete[] arr[i];
    }
    delete[] arr;
    arr = NULL;// c++에서는 arr = nullptr 로 하는게 안전하다. 왜냐하면, NULL은 0과 같은의미라서 상수로 
    return 0;
  }
```
## ENUM
```c++
enum class A{red, yellow, green};
enum class B{a, b, c, d};

B jobnum = B::A;
int i = static_cast<int>(A::green)
`A::red == B::c` // 이런 코드는 이제 error 처리 된다.
```
## 문자열 string

c에서의 문자열 => char[] 또는  char* 를 사용했음. (참고; 비교/연결/길이 = strcmp/ strcat/ strlen)

c++에서의 문자열 => #include<string> string stn = 'Hello' (참고; 비교연결길이 = ==/ +/ )

## Reference : 어떤 변수의 또 다른 별명 지어주기
```c++
int x= 5;
int& ref = x; // & 는 주소를 의미하는게 아니라, 참조(reference)를 의미한다.
//이렇게 하면 x의 별명이 ref가 되는거임. 따라서 밑에 두문장이 결국 같은 관계가 되는거임.
ref = 5;
x = 5;
```
## call by reference 
```C++
void swap(int& a, int& b){ //&는 주소가 아니라 참조(reference)다 ~.
    int temp = a;
    a = b;
    b = temp;
}
```
## 함수 오버로딩; 여러함수에서 같은 이름쓰기 
__단,__ 오버로딩된 함수끼리는 인수의 개수가 달라야됨. 인수개수가 같은데 잘 되려면, 인수들의 타입이 달라야됨.

__만약에,__ 함수의 이름, 인수들의 타입은 동일하면서 해당함수의 리턴형식만 다른 두 함수라면 그거는 불가능하다. 오버로딩이 안됨. 컴파일 x

## Class 클래스 !
차이 | 구조체(struct) | 클래스(class)
|--------|:------:|------:|
|'함수 담기'| 불가능 | 가능 |
|해당 객체 박에서 멤버에 접근가능? | 가능 | 불가능 |

class 정의 후, __객체를 생성하는 행위  == 인스턴스화 (instantiation)__ 

또한 class에서 멤버함수(= method) 는 선언은 내부에서 하고 정의를 내부/ 외부 둘다 할수 있음.  
이때, 내부에서 정의되면 모두 인라인함수 (inline function) 이라고 정의된다.

## Access specifier
종류 | 설명
|-----|:------:|
'public'| 클래스 외부에서도 접근가능, 모두 열린상태
'protected'| 자식클래스의 멤버함수 에서만 접근 가능
'private' | 자신의 멤버함수에서만 접근가능

## Information Hiding/ Encapsulation(캡슐화)

사용자가 굳이 알 필요없는 정보들을 숨김으로써, 사용자가 최소한의 정보로 사용할수 있게 하는것이 목표
->보통, 멤버함수 - public  
멤버변수 - private 으로 선언하여, 변수로의 직접접근을 막고, 함수를 통한 간접 접근은 허용 시켜놓는다.  
Information Hiding : private 같은 걸로 정보 숨기기
Encapsulation : 데이터를 class/구조체를 이용하여 묶어두기  

## Constructor / Destructor

생성자는 오버로드 가능하다.  
```c++
Line(int age){
 본문내용
}
```
소멸자는 생성자와 비슷하게 생겼지만 선언할때, 앞에 ~를 붙인다.
```c++
~Line(){
 본문내용
}
```
또한, 생성할때, A B객체 순으로 생성했으면, 소멸순서는 B->A 순서로 소멸시켜야한다.
(메모리가 stack 구조 이기 때문)

```c++
class Person{
private:
    const string SSN;
    double height;
    double weight;
public:
    ~~~~~~~~~~~~~~~~~~
    Person(const string _SSN, double _height; double _weight){
        SSN = _SSN; //바로여기 
        height = _height;
        weight = _weight;
    }
    ~~~~~~~~~~~~~~~~~~~
};

int main(){
    Person P("brain", 183.4, 78.5);
}
```

이때, 위의 코드에는 오류가 발생한다. 바로 선이 그어져있는 부분에서 발생하는데, 이유는 const변수는 값대입이 불가능하고, 선언과 동시에 값이  
주어져야 하기 때문.
따라서 저 문장은 이렇게 바뀌어야 한다.

```C++
Person(const string _SSN, double _height; double _weight): SSN(_SSN), height(_height), weight(_weight){ }
```








미크다운 정리페이지 https://heropy.blog/2017/09/30/markdown/

